/*
 * link_dma_tx.asm
 *
 *  Created on: 24 окт. 2021 г.
 *      Author: MKrizhanovskiy
 */
#include <defts201.h>
//задаем длительность импульсов
#define dlit_imp 10000
//задаем девиацию
#define dev_f 0.01
//шаг расчитывается исходя из приведенных выше данных
#define step_dev dev_f/dlit_imp
.SECTION /DOUBLE64 /CHAR32 .data;
.ALIGN 4;
//.var arrt[4096];
.VAR sin_arr[dlit_imp*7];// массив чтоб сейвить
.var task_T[4]={0,0,0,0};
.VAR  sin_coef[5]={3.140625,0.02026367,-5.325196,0.5446778,1.800293};//масивчик с кэффициентами

//.VAR arr2[dlit_imp];// массив чтоб сейвить
//.VAR arr3[60000];// массив чтоб сейвить
.var buf[]={0,1,0,1,1,0};//буфер данных
.var stack[100];//создаем стек
.SECTION .program;
.ALIGN_CODE 4;
.GLOBAL _main;
.GLOBAL LINK2_tr_init;
.GLOBAL dma6_init;
.GLOBAL lfm_func;
.GLOBAL sin_func;
.global gen_lfm_sin_arr;
_main:
j0=stack;;//указатель на стек
SQCTL = 0x1200;;//переход в режим супервизора
j1=0x1f;;
FLAGREG=j1;;
call gen_lfm_sin_arr;nop;nop;;
call LINK2_tr_init;nop;nop;;
call dma6_init;nop;nop;;
_main_loop:
nop;nop;nop;;
nop;nop;nop;;
nop;nop;nop;;
nop;nop;nop;;
nop;nop;nop;;
nop;nop;nop;;
nop;nop;nop;;
nop;nop;nop;;
nop;nop;nop;;
jump _main_loop;nop;;
_main.end:



LINK2_tr_init:
[j0+=1]=j1;;
[j0+=1]=cjmp;;
[j0+=1]=xr0;;
[j0+=1]=xr1;;
[j0+=1]=xr2;;
[j0+=1]=xr3;;


//выключим для начала линки
j1=0;;
LRCTL0=j1;;
LRCTL1=j1;;
LRCTL2=j1;;
LRCTL3=j1;;
LtCTL2=j1;;
//и их dma каналы
xr0=0;
xr1=0;;
xr2=0;;
xr3=0;;
dc11=xr3:0;;
dc10=xr3:0;;
dc9 =xr3:0;;
dc8 =xr3:0;;
dc7=xr3:0;;

//Включаем линк передатчика
j1=(1<<4)+(4<<5);;//формат 4 бит
LtCTL2=j1;;
lc0 = 10;;
dly_p1: if nlc0e, jump dly_p1;; //подождем
//включаем
j1=1+(1<<4)+(4<<5);;
LtCTL2=j1;;
lc0 = 1000;;
dly_p2: if nlc0e, jump dly_p2;; // дадим приемнику время подготовиться


j0=j0-1;;//отпушим
xr3=[j0 + 0];;
j0=j0-1;;
xr2=[j0 + 0];;
j0=j0-1;;
xr1=[j0 + 0];;
j0=j0-1;;
xr0=[j0 + 0];;
j0=j0-1;;
cjmp=[j0 + 0];;
j0=j0-1;;
j1=[j0 + 0];;
cjmp(abs);;
LINK2_tr_init.end:

dma6_init:
[j0+=1]=xr0;;
[j0+=1]=xr1;;
[j0+=1]=xr2;;
[j0+=1]=xr3;;
[j0+=1]=cjmp;;

//Настраиваем и включаем DMA передатчика
xr0=sin_arr;;
xr1=0xEA600004;;
xr2=0;;
xr3=0x40000000/*выбираем внутреннюю память*/+ (6<<19)/*выбираем номер порта линк и направление
*/ + (3<<25) /*ставим длинну данных*/ /*+ (1<<22) разрешение след передачи
*/ + (task_T/4);; //указатель на след цепочку
q[j31+task_T]=xr3:0;;
dc6=xr3:0;;

j0=j0-1;;//отпушим
cjmp=[j0 + 0];;
j0=j0-1;;
xr3=[j0 + 0];;
j0=j0-1;;
xr2=[j0 + 0];;
j0=j0-1;;
xr1=[j0 + 0];;
j0=j0-1;;
xr0=[j0 + 0];;
cjmp(abs);;
dma6_init.end:


//*******************************************************************************************

//*******************************************************************************************
//эта функция дает массив длины __\
значений синусоиды с частотой __\
//*******************************************************************************************
gen_lfm_sin_arr:
	[j0+=1]=cjmp;;
	[j0+=1]=yr1;;
	[j0+=1]=yr2;;
	[j0+=1]=xr1;;
	[j0+=1]=xr17;;
	yr1=6;;//счетчик буфера
	xr1=0.0;// начальное значение x
	j4=sin_arr;;//указатель на буфер куда сгружаем все
	j5=buf;;//указатель на буфер данных
	//генерим массив данных которые мы типо приняли
	m4:
	call lfm_func;NOP; NOP; NOP;;
	xr17=[j5+=1];//хватаем начиная с первого биты из массива данных
	yr2=dec r1;;//изменяем счетчик колличества переданых битов
	yr1=yr2;;
	if nyaeq, jump m4;NOP; NOP;NOP;;
	j0=j0-1;;
	xr17=[j0 + 0];;
	j0=j0-1;;
	xr1=[j0 + 0];;
	j0=j0-1;;
	yr2=[j0 + 0];;
	j0=j0-1;;
	yr1=[j0 + 0];;
	j0=j0-1;;
	cjmp=[j0 + 0];;
cjmp(abs);;
gen_lfm_sin_arr.end:

//*******************************************************************************************
//функция выдает массив значений лчм сигнала\
выведенные данные складируются по адресу [j4+0]\

//*******************************************************************************************
lfm_func:
	//пушим в стек
	[j0+=1]=cjmp;;
	[j0+=1]=lc1;;
	[j0+=1]=xr16;;
	[j0+=1]=xr17;;
	[j0+=1]=xr18;;
	[j0+=1]=xr5;;
	[j0+=1]=xr6;;
	[j0+=1]=xr9;;
	xr16=0.000001;;	//здесь задаем частоту стартовую
	lc1=dlit_imp-1;; //задаем кол-во итераций (диапазон изменения входных значений)
	m:
		xr17=step_dev;; //0.000001;;//множитель в уравнении y=kx для лчм
		xr18=dev_f;;//2;;	//0.01;;//dev_f;;//задаем пиковую частоту
		xr5=lc1;;//x
		xr6=dlit_imp/2;;///2;;//10000;;//dlit_imp/2;;//задаем длительность половины импульса ЛЧМ
		xfr6=float r6;;//переводим в плав точку
		xfr5=float r5;;//переводим в плав точку
		xfr16=r5*r17;;//x*k
		xfcomp(r5,r6);;//сравнение x и длительности импульса
		if xalt, jump k;;
		//если  x>длительности_импульса/2
		xfr16=r5*r17;;//x*k
		xfr16=r18-r16;;//dev_f-x*k
		xr6=0.000001;;
		k:
		xr17=1;;//просто нолик шоб было с чем сравнивать
		xr18=[j5+0];;//жрем данные из буфера
		xcomp(r18,r17);;//жуем
		if xaeq,jump mk;;//делаем выводы о вкусовых качествах
			xr16=0;;//start_f;;
			xr9=0;;NOP; NOP; NOP;;
			jump collect;;
		mk:
		Xfr1=r1+r16;;//изменяем х на единицу
		call sin_func;NOP; NOP; NOP;;//переход по метке
		collect:
		[J4+=1]= xr9;;//складируем все это ОНИМЭ
	if NLC1E, jump m;NOP; NOP; NOP;;
	//отпушиваем стек
	j0=j0-1;;
	xr9=[j0 + 0];;
	j0=j0-1;;
	xr6=[j0 + 0];;
	j0=j0-1;;
	xr5=[j0 + 0];;
	j0=j0-1;;
	xr18=[j0 + 0];;
	j0=j0-1;;
	xr17=[j0 + 0];;
	j0=j0-1;;
	xr16=[j0 + 0];;
	j0=j0-1;;
	lc1=[j0 + 0];;
	j0=j0-1;;
	cjmp=[j0 + 0];;
	cjmp(abs);;
lfm_func.end:

//*******************************************************************************************
//нижже функция синуса которая понимает числа от 0 до 1.84\
число пи соответствует значению 0.92\
выходное значение подается через xr9\
входное значение подается через xr1
//*******************************************************************************************
sin_func:
//пушим в стек
	[j0+=1]=j3;;
	[j0+=1]=xr15;;
	[j0+=1]=xr10;;
	[j0+=1]=xr5;;
	[j0+=1]=xr2;;
	[j0+=1]=xr6;;
	[j0+=1]=xr3;;//
	[j0+=1]=cjmp;;
	[j0+=1]=lc0;;
	j3=sin_coef;;
	beg:
	xr15=0.46;;
	xfcomp(r1,r15);;
	if xalt,jump m1;;//x<0,46
	xr10=0.92;;//x>0,46
	xfr5=r10-r1;;
	xfcomp(r1,r10);;
	if xalt,jump m3;;//x<0,92
	xfr5=r1-r10;;//x>0,96
	xr10=1.38;;
	xfcomp(r1,r10);;
	if xalt,jump m3;;//x<1.38
	xr10=1.84;;
	xfr5=r10-r1;;//x>1.38
	xfcomp(r1,r10);;//r1<1.84
	if xalt,jump m3;;
	xfr1=r1-r10;;//если значение больше 2*пи\
	отнимаем от него пи пока это не изменится
	jump beg;NOP; NOP; NOP;;
	jump m3;NOP; NOP; NOP;;
	m1:
	xr5= xr1;;
	m3:
	xr2=[j3+=1];; //c1
	xr6=xr5;
	xfr3=r5*r2;;//c1*x
	lc0=3;;//стартуем еще цикл
	m2:
	xr2=[j3+=1];;//c2,c3,c4
	xfr5=r5*r6;;//x^2,x^3,x^4
	xfr7=r5*r2;;//c2*x^2,c3*x^3,c4*x^5
	xfr3=r3+r7;;
	if NLC0E, jump m2;;
	xr10=1000.0;;
	xfr3=r3*r10;;//масштабируем результат перед переводом в тип с фиксированой точкой
	xr9=fix xfr3;;//округляем конечный результат чтоб матлаб не подавился странным форматом плавающей точки
	//работа со знаком отменена в виду того что матлаб странно пережевывает числа с отрицательным знаком
	//работа со знаком
	xr10=0.92;;
	xfcomp(r1,r10);;
	if xalt,jump m5;;//x<0.92
	xr10=0;;
	xr9=r10-r9;;
	//jump m6;;
	m5:
	//xr9=r9+r10;;
	m6:
	//пушим из стека
	j0=j0-1;;
	lc0=[j0 + 0];;
	j0=j0-1;;
	cjmp=[j0 + 0];;
	j0=j0-1;;
	xr3=[j0 + 0];;
	j0=j0-1;;
	xr6=[j0 + 0];;
	j0=j0-1;;
	xr2=[j0 + 0];;
	j0=j0-1;;
	xr5=[j0 + 0];;
	j0=j0-1;;
	xr10=[j0 + 0];;
	j0=j0-1;;
	xr15=[j0 + 0];;
	j0=j0-1;;
	j3=[j0 + 0];;
	cjmp(abs);;
sin_func.end:
